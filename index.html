<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Global Trade Network Analyzer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    
    <style>
        /* =========================== */
        /* RESET AND BASE STYLES       */
        /* =========================== */
        
        * {
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #f8fafc;
            color: #374151;
            min-height: 100vh;
            overflow: hidden; /* Prevent body scrollbars */
        }

        .hidden {
            display: none !important;
        }

        /* =========================== */
        /* LOADING OVERLAY             */
        /* =========================== */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(248, 250, 252, 0.8);
            backdrop-filter: blur(4px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 16px;
            transition: opacity 0.3s ease;
        }
        .spinner {
            width: 48px;
            height: 48px;
            border: 5px solid #d1d5db;
            border-bottom-color: #3b82f6;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loading-text {
            font-size: 1rem;
            font-weight: 500;
            color: #4b5563;
        }


        /* =========================== */
        /* CONTROL PANEL STYLES        */
        /* =========================== */
        
        #panel-container {
            position: fixed;
            top: 24px;
            left: 24px;
            z-index: 100;
            max-height: calc(100vh - 48px);
            display: flex;
            transition: width 0.3s ease;
        }

        #control-panel {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            width: 360px;
            max-height: 100%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transition: width 0.3s ease, padding 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        #control-panel.collapsed #panel-content {
            display: none;
        }

        #panel-content {
            padding: 0 20px 20px 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .hide-on-collapse {
            transition: opacity 0.3s ease;
        }

        #control-panel.collapsed .hide-on-collapse {
            display: none;
            opacity: 0;
        }

        /* Panel Header */
        #title {
            padding: 20px 20px 0 20px;
            margin: 0 0 6px 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: #111827;
            line-height: 1.2;
            transition: all 0.3s ease;
            /* Make space for new icon button */
            padding-right: 110px; 
        }

        #subtitle {
            padding: 0 20px;
            margin-bottom: 12px;
            font-size: 0.875rem;
            color: #6b7280;
            line-height: 1.4;
            transition: all 0.3s ease;
            /* Make space for new icon button - REMOVED for better text flow */
            /* padding-right: 110px; */
        }

        /* --- NEW: Link style for subtitle --- */
        .subtitle-link {
            color: inherit;
            text-decoration: none;
            border-bottom: 1px dotted #6b7280;
            transition: all 0.2s ease;
        }
        .subtitle-link:hover {
            color: #3b82f6;
            border-bottom-style: solid;
            border-bottom-color: #3b82f6;
        }

        /* Toggle Button */
        #panel-toggle-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 101;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        #panel-toggle-btn:hover {
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .toggle-icon {
            display: flex;
            flex-direction: column;
            gap: 3px;
            transition: transform 0.2s ease;
        }

        .toggle-line {
            width: 16px;
            height: 2px;
            background: #6b7280;
            border-radius: 1px;
            transition: all 0.2s ease;
        }

        #control-panel.collapsed .toggle-icon {
            transform: rotate(180deg);
        }

        #panel-toggle-btn:hover .toggle-line {
            background: #374151;
        }
        
        /* --- NEW: About Icon Button --- */
        #about-icon-btn {
            position: absolute;
            top: 12px;
            right: 60px; /* 12px right + 40px toggle btn + 8px gap */
            z-index: 101;
        }
        /* --- END NEW --- */

        /* =========================== */
        /* SECTION STYLES              */
        /* =========================== */
        
        .section {
            margin-bottom: 20px;
            padding: 12px;
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        .section:first-child {
            margin-top: 20px;
        }

        .section h3 {
            margin: 0 0 8px 0;
            color: #111827;
            font-size: 0.95rem;
            font-weight: 600;
        }

        .section-description {
            font-size: 0.8rem;
            color: #6b7280;
            margin-bottom: 12px;
        }

        /* =========================== */
        /* METRICS GRID                */
        /* =========================== */
        
        #metrics {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .metric-card {
            padding: 12px;
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .metric-value {
            font-size: 1rem;
            font-weight: 600;
            color: #111827;
            margin: 0;
        }

        .metric-label {
            font-size: 0.7rem;
            color: #6b7280;
            margin: 4px 0 0 0;
        }

        /* =========================== */
        /* CONTROLS AND BUTTONS        */
        /* =========================== */
        
        #country-search, #product-category-select {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.85rem;
            background: #ffffff;
            color: #374151;
            transition: all 0.2s ease;
        }
        
        #partnership-select {
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            border: 1px solid #d1d5db;
            color: #374151;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 500;
            flex: 2; /* Take up more space */
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            -webkit-appearance: none; /* Allows custom styling on selects */
            -moz-appearance: none;
            appearance: none;
            /* Custom arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 1em;
            padding-right: 2.5rem; /* Make room for the arrow */
        }

        #country-search:focus, #product-category-select:focus, #partnership-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        #country-search::placeholder {
            color: #9ca3af;
        }

        #country-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-bottom: 12px;
            padding-right: 8px;
            max-height: 220px;
            overflow-y: auto;
        }

        .country-toggle {
            padding: 10px 14px;
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            text-align: left;
            color: #374151;
            transition: all 0.2s ease;
        }

        .country-toggle:hover {
            border-color: #9ca3af;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .country-toggle.active {
            background: #10b981;
            border-color: #10b981;
            color: #ffffff;
        }

        .country-toggle.inactive {
            background: #ef4444;
            border-color: #ef4444;
            color: #ffffff;
        }

        .view-controls {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            align-items: center;
        }

        .view-btn, .modal-btn {
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            border: 1px solid #d1d5db;
            color: #374151;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 500;
            flex: 1;
            text-align: center;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .view-btn:hover, #partnership-select:hover, .modal-btn:hover {
            border-color: #9ca3af;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .view-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: #ffffff;
        }

        #stats {
            font-size: 0.8rem;
            color: #6b7280;
            text-align: center;
            padding: 8px;
            background: #ffffff;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
            margin-bottom: 0;
        }

        /* =========================== */
        /* 2D GRAPH AND LEGEND         */
        /* =========================== */
        
        #graph {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
            background: #f8fafc;
        }

        #legend {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 18px;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            max-width: 180px;
        }

        #legend-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #111827;
            margin: 0 0 10px 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 0.75rem;
            color: #374151;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* =========================== */
        /* TOOLTIP STYLES              */
        /* =========================== */
        
        #mobile-tooltip {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 105;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .force-graph-tooltip {
            background: transparent !important;
            padding: 0 !important;
            border: none !important;
            box-shadow: none !important;
        }

        .graph-tooltip {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            color: #f1f5f9;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 14px;
            font-weight: 500;
            line-height: 1.4;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            max-width: 200px;
            text-align: center; /* Center flag and text */
        }
        
        .tooltip-flag {
            width: 48px;
            height: auto;
            border-radius: 4px; /* Soften the corners */
            object-fit: contain;
            border: 1px solid #cbd5e1; /* Lighter border */
            margin-bottom: 8px;
        }
        
        .graph-tooltip .tooltip-row {
            margin-bottom: 2px;
            text-align: left;
        }

        .tooltip-country {
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 6px;
            font-size: 16px;
        }
        
        .tooltip-key {
            font-weight: 600;
            color: #94a3b8;
            margin-right: 6px;
        }

        /* =========================== */
        /* MATRIX & MODAL STYLES       */
        /* =========================== */
        
        #top-right-controls {
            position: fixed;
            top: 24px;
            right: 24px;
            z-index: 101;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            color: #374151;
            transition: all 0.2s ease;
        }
        .icon-btn:hover {
            border-color: #d1d5db;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            color: #111827;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(4px);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .modal-container {
            background: #ffffff;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            position: relative;
            max-width: 90vmin;
            max-height: 90vmin;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #111827;
            margin: 0 0 16px 0;
            padding-right: 30px;
            flex-shrink: 0;
            align-self: flex-start;
        }

        .modal-close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 28px;
            height: 28px;
            border: none;
            background: #f3f4f6;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            color: #6b7280;
        }
        .modal-close-btn:hover {
            background: #e5e7eb;
            color: #111827;
        }
        
        #matrix-canvas-container {
            flex-grow: 1;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f1f5f9;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
        }

        #matrix-canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        #matrix-legend {
            margin-top: 12px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            width: 100%;
        }
        #legend-gradient {
            height: 12px;
            flex-grow: 1;
            border-radius: 6px;
        }

        /* Data Modal Specifics */
        #data-modal-content {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #374151;
            width: 100%;
            max-width: 600px;
        }
        #data-modal-content h4 {
            font-size: 1rem;
            font-weight: 600;
            color: #111827;
            margin-top: 16px;
            margin-bottom: 8px;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 4px;
        }
        #data-modal-content ul {
            padding-left: 20px;
            margin-top: 0;
            margin-bottom: 12px;
        }
        #data-modal-content li {
            margin-bottom: 6px;
        }
        #data-modal-content p {
            margin-top: 0;
            margin-bottom: 12px;
        }
        
        /* =========================== */
        /* RESPONSIVE ADJUSTMENTS      */
        /* =========================== */
        @media (max-width: 640px) {
            #top-right-controls {
                display: none; /* Hide matrix button on small screens */
            }
            #panel-container {
                top: 12px;
                left: 12px;
                right: 12px;
                width: auto;
                max-height: calc(100vh - 24px);
            }
            #control-panel {
                width: 100%;
            }
            /* Adjust title/subtitle padding for mobile */
            #title, #subtitle {
                padding-right: 110px; 
            }
        }

        /* =========================== */
        /* SCROLLBAR STYLES            */
        /* =========================== */
        
        ::-webkit-scrollbar {
            width: 4px;
            height: 4px;
        }

        ::-webkit-scrollbar-track {
            background: #f3f4f6;
        }

        ::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 2px;
        }
    </style>

    <script src="//cdn.jsdelivr.net/npm/force-graph"></script>
</head>

<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Loading Network Data...</div>
    </div>

    <div id="panel-container">
        <div id="control-panel">
            <button id="panel-toggle-btn">
                <div class="toggle-icon">
                    <span class="toggle-line"></span>
                    <span class="toggle-line"></span>
                    <span class="toggle-line"></span>
                </div>
            </button>
            
            <!-- --- NEW: About Icon Button --- -->
            <button id="about-icon-btn" class="icon-btn" title="About the Data">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
            </button>
            <!-- --- END NEW --- -->
            
            <h1 id="title">Global Trade Network</h1>
            <!-- --- EDITED: New Subtitle --- -->
            <p id="subtitle">A network analysis project from the <a href="https://santafe.edu/info/2025-complexity-global-school/overview" target="_blank" rel="noopener noreferrer" class="subtitle-link">2025 Complexity Global School (SFI & Uniandes)</a>.</p>
            
            <div id="panel-content">
                <div class="section hide-on-collapse">
                    <h3>Network Metrics</h3>
                    <p class="section-description">Key measures of network structure</p>
                    <div id="metrics">
                        <div class="metric-card">
                            <div class="metric-value" id="active-countries">0</div>
                            <div class="metric-label">Countries</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="trade-links">0</div>
                            <div class="metric-label">Trade Links</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="network-density">0.000</div>
                            <div class="metric-label">Density</div>
                        </div>
                    </div>
                </div>

                <div class="section hide-on-collapse">
                    <h3>Product Category</h3>
                    <p class="section-description">Select a product network to visualize</p>
                    <select id="product-category-select"></select>
                </div>

                <div class="section hide-on-collapse">
                    <h3>View Options</h3>
                    <p class="section-description">Choose how to visualize the network</p>
                    <div class="view-controls">
                        <button class="view-btn" data-view="degree" onclick="app.setView('degree')">Degree</button>
                        <button class="view-btn" data-view="betweenness" onclick="app.setView('betweenness')">Between</button>
                        <button class="view-btn active" data-view="closeness" onclick="app.setView('closeness')">Close</button>
                    </div>
                    <div class="view-controls" style="margin-top: 12px;">
                        <button id="flag-toggle-btn" class="view-btn active">Toggle Flags</button>
                    </div>
                </div>

                <div class="section hide-on-collapse">
                    <h3>Countries</h3>
                    <p class="section-description">Toggle countries on and off</p>
                    <div class="view-controls">
                        <button class="view-btn" onclick="app.selectAll()">All</button>
                        <button class="view-btn" onclick="app.selectNone()">None</button>
                        <select id="partnership-select" onchange="app.selectPartnership(this.value)"></select>
                    </div>
                    <input type="text" id="country-search" placeholder="Search countries..." class="hide-on-collapse">
                    <div id="country-grid" class="hide-on-collapse"></div>
                    <div id="stats" class="hide-on-collapse">
                        <span id="active-count">0</span> countries, <span id="link-count">0</span> links
                    </div>
                </div>

                <!-- --- REMOVED: Old About Section --- -->
                <!--
                <div class="section hide-on-collapse">
                    <h3>About</h3>
                    <p class="section-description">Data source and project info</p>
                    <button id="data-modal-btn" class="modal-btn">About the Data</button>
                </div>
                -->
            </div>
        </div>
    </div>

    <div id="top-right-controls">
        <button id="matrix-toggle-btn" class="icon-btn" title="Show Adjacency Matrix">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
        </button>
    </div>

    <div id="legend">
        <h4 id="legend-title">Legend</h4>
    </div>

    <div id="graph"></div>
    <div id="mobile-tooltip" class="hidden"></div>

    <!-- Adjacency Matrix Modal -->
    <div id="matrix-overlay" class="modal-overlay hidden">
        <div id="matrix-container" class="modal-container">
            <h3 id="matrix-title" class="modal-title">Adjacency Matrix: <span id="matrix-category-name"></span></h3>
            <button id="matrix-close-btn" class="modal-close-btn">&times;</button>
            <div id="matrix-canvas-container">
                <canvas id="matrix-canvas"></canvas>
            </div>
            <div id="matrix-legend">
                <span id="legend-min">0</span>
                <div id="legend-gradient"></div>
                <span id="legend-max">0</span>
            </div>
        </div>
    </div>

    <!-- About the Data Modal -->
    <div id="data-modal-overlay" class="modal-overlay hidden">
        <div id="data-modal-container" class="modal-container">
            <h3 id="data-modal-title" class="modal-title">About the Data</h3>
            <button id="data-modal-close-btn" class="modal-close-btn">&times;</button>
            <div id="data-modal-content">
                
                <h4>Data Status</h4>
                <p>This is a static website. The underlying data was retrieved in <strong>October 2025</strong> and will not be updated automatically.</p>

                <h4>Our Relationship to the Data</h4>
                <p>This is an independent data visualization project and is not affiliated with, endorsed by, or connected to the World Trade Organization (WTO). All data is sourced from the official WTO Stats dashboard, but this tool is not an official WTO product.</p>

                <h4>Data Source & Methodology</h4>
                <p>The data displayed in this visualization is sourced from the <a href="https://stats.wto.org/dashboard/tradeconnectivity_en.html" target="_blank" rel="noopener noreferrer">WTO Trade Connectivity Heatmap</a>.</p>
                <ul>
                    <li>The visualization is based on the latest available (but no earlier than 2015) import data from UN Comtrade or the WTO Integrated Database (IDB).</li>
                    <li>All export statistics are based on mirror statistics (i.e., calculated using import data).</li>
                    <li>Economies shown are those with total imports from the world worth more than 5 billion US$.</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // =========================== //
        // GLOBAL APPLICATION OBJECT   //
        // =========================== //
        
        const app = {
            // Core data
            gData: { nodes: [], links: [] },
            nodeMap: new Map(),
            adjacencyMatrix: [],
            flagImageCache: {}, // Cache for flag images
            linkMinMax: { min: 0, max: 0 }, // <-- ADDED
            
            // State for highlighting
            highlightNodes: new Set(),
            highlightLinks: new Set(),
            hoverNode: null,

            // Application state
            graph: null,
            currentView: 'closeness',
            viewMinMax: {},
            productCategories: [],
            showFlags: true,

            partnerships: {
                "BRICS": ["C076", "C643", "C356", "C156", "C710"],
                "USMCA": ["C840", "C124", "C484"],
                "EU Core": ["C276", "C250", "C380", "C724"]
            },

            // Color schemes
            regionColors: {
                "North America": "#ef4444", "South America": "#10b981", "Europe": "#3b82f6",
                "Asia": "#f59e0b", "Oceania": "#06b6d4", "Middle East": "#d97706", "Africa": "#84cc16"
            },
            centralityColors: {
                degree: { high: '#8b5cf6', medium: '#a78bfa', low: '#c4b5fd' },
                betweenness: { high: '#ef4444', medium: '#f87171', low: '#fca5a5' },
                closeness: { high: '#10b981', medium: '#34d399', low: '#6ee7b7' },
            },

            async fetchJSON(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Could not fetch JSON from ${url}:`, error);
                    return null;
                }
            },

            async init() {
                document.getElementById('loading-overlay').classList.remove('hidden');
                console.log("App initializing...");
                
                app.setupEventListeners();
                await app.populateCategorySelector();
                app.populatePartnershipSelector();

                app.initializeGraph();

                await app.loadInitialData();
                
                if (app.productCategories.length > 0) {
                    const defaultCategory = app.productCategories.includes("All Products") ? "All Products" : app.productCategories[0];
                    await app.switchNetwork(defaultCategory);
                    app.selectPartnership("BRICS");
                } else {
                    console.error("No product categories loaded. Cannot initialize network.");
                    document.getElementById('loading-text').textContent = 'Error: product-categories.json not found or is empty.';
                    document.getElementById('loading-overlay').classList.add('hidden');
                    return;
                }
                
                console.log("App initialization complete.");
            },

            async loadInitialData() {
                app.nodeMap.clear();
                const countryCodes = await app.fetchJSON('./data/country-codes.json');
                const metadata = await app.fetchJSON('./data/country-metadata.json');

                if (countryCodes) {
                    for (const [id, name] of Object.entries(countryCodes)) {
                        app.nodeMap.set(id, { id, name, active: true, region: 'Unknown' });
                    }
                }

                if (metadata && Array.isArray(metadata)) {
                    metadata.forEach(countryData => {
                        if (countryData.id && app.nodeMap.has(countryData.id)) {
                            const existingNode = app.nodeMap.get(countryData.id);
                            app.nodeMap.set(countryData.id, { ...existingNode, ...countryData });
                        }
                    });
                }
                console.log(`Initialized ${app.nodeMap.size} countries.`);
            },

            async switchNetwork(category) {
                document.getElementById('loading-overlay').classList.remove('hidden');
                document.getElementById('loading-text').textContent = `Loading ${category}...`;
                
                try {
                    document.getElementById('product-category-select').value = category;

                    // Filename for edge-list (uses underscores)
                    let edgeListFilename = category.replace(/\//g, '_or_').replace(/ /g, '_');
                    const edgeListPath = `./data/edge-lists/edge-list-${edgeListFilename}.json`;
                    
                    // Filename for edge-weights (uses spaces)
                    let edgeWeightsFilename = category;
                    const edgeWeightsPath = `./data/edge-weights/edge-weights-${edgeWeightsFilename}.json`;

                    // Fetch both files in parallel
                    const [edgeList, edgeWeights] = await Promise.all([
                        app.fetchJSON(edgeListPath),
                        app.fetchJSON(edgeWeightsPath)
                    ]);

                    if (!edgeList) {
                        throw new Error(`Edge list for "${category}" could not be loaded. Check if the file exists at: ${edgeListPath}`);
                    }
                    
                    if (!edgeWeights) {
                        console.warn(`Edge weights for "${category}" not found at ${edgeWeightsPath}. Using default value of 1.`);
                    }

                    // Reset all node metrics
                    app.nodeMap.forEach(node => {
                        node.degree = 0;
                        node.closeness = 0;
                        node.betweenness = 0;
                        node.trade_volume = 0;
                    });
                    
                    edgeList.forEach(edge => {
                        const [sourceId, targetId] = edge;
                        if (!app.nodeMap.has(sourceId)) {
                            app.nodeMap.set(sourceId, { id: sourceId, name: `Country ${sourceId}`, active: true, region: 'Unknown' });
                        }
                        if (!app.nodeMap.has(targetId)) {
                            app.nodeMap.set(targetId, { id: targetId, name: `Country ${targetId}`, active: true, region: 'Unknown' });
                        }
                    });

                    app.gData.nodes = Array.from(app.nodeMap.values());
                    
                    const links = edgeList.map(edge => {
                        const [source, target] = edge;
                        let value = 1; // Default value if not found
                        
                        if (edgeWeights) {
                            // Key format in JSON is a stringified array: "[\"C124\",\"C004\"]"
                            const key = JSON.stringify([source, target]);
                            if (edgeWeights[key] !== undefined) {
                                value = edgeWeights[key];
                            }
                        }
                        
                        return { source, target, value };
                    });
                    app.gData.links = links;
                    
                    app.recomputeMetrics();
                    app.renderAdjacencyMatrix();
                    app.updateGraphData();
                    app.updateUI();

                } catch (error) {
                    console.error(`Failed to switch network to ${category}:`, error);
                    document.getElementById('graph').innerHTML = `<div style="text-align: center; padding: 40px; color: #ef4444;">
                        <h2>Error Loading Network</h2><p>${error.message}</p></div>`;
                } finally {
                    document.getElementById('loading-overlay').classList.add('hidden');
                }
            },

            async populateCategorySelector() {
                const categories = await app.fetchJSON('./data/product-categories.json');
                if (categories && categories.length > 0) {
                    app.productCategories = categories;
                    const select = document.getElementById('product-category-select');
                    select.innerHTML = '';
                    app.productCategories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category;
                        option.textContent = category;
                        select.appendChild(option);
                    });
                } else {
                    console.error("Could not load product categories from './data/product-categories.json'. The application may not function correctly.");
                }
            },

            populatePartnershipSelector() {
                const select = document.getElementById('partnership-select');
                select.innerHTML = '<option value="custom" disabled>Custom Selection</option>';
                for (const partnershipName in app.partnerships) {
                    const option = document.createElement('option');
                    option.value = partnershipName;
                    option.textContent = partnershipName;
                    select.appendChild(option);
                }
            },

            // Recomputes all metrics based on the *currently active* nodes
            recomputeMetrics() {
                document.getElementById('loading-text').textContent = 'Calculating Metrics...';
                document.getElementById('loading-overlay').classList.remove('hidden');

                const activeNodes = new Map();
                const activeNodeIds = new Set();
                app.nodeMap.forEach(node => {
                    if (node.active) {
                        // Reset metrics for active nodes
                        node.degree = 0;
                        node.closeness = 0;
                        node.betweenness = 0;
                        node.trade_volume = 0;
                        activeNodes.set(node.id, node);
                        activeNodeIds.add(node.id);
                    }
                });

                const activeLinks = app.gData.links.filter(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    return activeNodeIds.has(sourceId) && activeNodeIds.has(targetId);
                });

                const N = activeNodes.size;
                if (N === 0) {
                    app.updateMetrics(); // Update UI with zeros
                    document.getElementById('loading-overlay').classList.add('hidden');
                    return;
                }

                // --- 1. Build Adjacency List for Active Graph & Calculate Degrees ---
                const adj = new Map();
                const inDegree = new Map();
                const outDegree = new Map();

                activeNodes.forEach(node => {
                    adj.set(node.id, []);
                    inDegree.set(node.id, 0);
                    outDegree.set(node.id, 0);
                });

                activeLinks.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    adj.get(sourceId).push(targetId);
                    
                    // Total Directed Degree (In + Out)
                    outDegree.set(sourceId, outDegree.get(sourceId) + 1);
                    inDegree.set(targetId, inDegree.get(targetId) + 1);

                    // Trade Volume (In + Out)
                    const sourceNode = app.nodeMap.get(sourceId);
                    const targetNode = app.nodeMap.get(targetId);
                    sourceNode.trade_volume += link.value;
                    targetNode.trade_volume += link.value;
                });

                // Store total degree
                activeNodes.forEach(node => {
                    node.degree = inDegree.get(node.id) + outDegree.get(node.id);
                });

                // --- 2. Calculate Betweenness & Closeness (Brandes' Algorithm & Harmonic Closeness) ---
                const betweenness = new Map(Array.from(activeNodeIds).map(id => [id, 0.0]));
                const closeness = new Map(Array.from(activeNodeIds).map(id => [id, 0.0]));

                for (const s of activeNodeIds) {
                    const S = []; // Stack
                    const P = new Map(Array.from(activeNodeIds).map(id => [id, []])); // Predecessors
                    const sigma = new Map(Array.from(activeNodeIds).map(id => [id, 0.0])); // Number of shortest paths
                    const d = new Map(Array.from(activeNodeIds).map(id => [id, -1.0])); // Distance

                    sigma.set(s, 1.0);
                    d.set(s, 0.0);

                    const Q = [s]; // Queue
                    
                    let totalDistance = 0;
                    let reachableNodes = 0;

                    while (Q.length > 0) {
                        const v = Q.shift();
                        S.push(v);
                        
                        if (d.get(v) > 0) {
                           totalDistance += d.get(v);
                           reachableNodes++;
                        }

                        if (adj.has(v)) {
                            for (const w of adj.get(v)) {
                                // Path discovery
                                if (d.get(w) < 0) {
                                    Q.push(w);
                                    d.set(w, d.get(v) + 1);
                                }
                                // Path counting
                                if (d.get(w) === d.get(v) + 1) {
                                    sigma.set(w, sigma.get(w) + sigma.get(s));
                                    P.get(w).push(v);
                                }
                            }
                        }
                    }
                    
                    // Harmonic Closeness for node s
                    closeness.set(s, (reachableNodes > 0) ? (reachableNodes / totalDistance) : 0);

                    // Betweenness dependency accumulation
                    const delta = new Map(Array.from(activeNodeIds).map(id => [id, 0.0]));
                    while (S.length > 0) {
                        const w = S.pop();
                        for (const v of P.get(w)) {
                            const c = (sigma.get(v) / sigma.get(w));
                            delta.set(v, delta.get(v) + c * (1 + delta.get(w)));
                        }
                        if (w !== s) {
                            betweenness.set(w, betweenness.get(w) + delta.get(w));
                        }
                    }
                }

                // --- 3. Finalize & Normalize Metrics ---
                const normalizationFactor = (N > 2) ? ((N - 1) * (N - 2)) : 1.0; // Directed graph normalization

                activeNodes.forEach(node => {
                    node.betweenness = betweenness.get(node.id) / normalizationFactor;
                    node.closeness = closeness.get(node.id);
                    // node.degree and node.trade_volume already set
                });
                
                // --- 4. Update UI ---
                app.updateUI(); // This updates metrics panel, min/max values, etc.
                document.getElementById('loading-overlay').classList.add('hidden');
            },


            setupEventListeners() {
                document.getElementById('panel-toggle-btn').onclick = () => document.getElementById('control-panel').classList.toggle('collapsed');
                document.getElementById('country-search').addEventListener('input', () => app.updateCountryButtons());
                document.getElementById('product-category-select').onchange = (e) => app.switchNetwork(e.target.value);
                
                // Matrix Modal
                const matrixOverlay = document.getElementById('matrix-overlay');
                document.getElementById('matrix-toggle-btn').onclick = () => matrixOverlay.classList.remove('hidden');
                document.getElementById('matrix-close-btn').onclick = () => matrixOverlay.classList.add('hidden');
                matrixOverlay.onclick = (e) => { if (e.target === matrixOverlay) matrixOverlay.classList.add('hidden'); };
                
                // Data Modal
                const dataOverlay = document.getElementById('data-modal-overlay');
                // --- EDITED: Swapped listener to new button ---
                // document.getElementById('data-modal-btn').onclick = () => dataOverlay.classList.remove('hidden'); // Old button removed
                document.getElementById('about-icon-btn').onclick = () => dataOverlay.classList.remove('hidden'); // New icon button
                document.getElementById('data-modal-close-btn').onclick = () => dataOverlay.classList.add('hidden');
                dataOverlay.onclick = (e) => { if (e.target === dataOverlay) dataOverlay.classList.add('hidden'); };

                // Flag Toggle
                document.getElementById('flag-toggle-btn').onclick = () => {
                    app.showFlags = !app.showFlags;
                    document.getElementById('flag-toggle-btn').classList.toggle('active', app.showFlags);
                    app.graph.nodeCanvasObject(app.graph.nodeCanvasObject()); // Re-render nodes
                };
            },

            renderAdjacencyMatrix() {
                const canvas = document.getElementById('matrix-canvas');
                const ctx = canvas.getContext('2d');

                const category = document.getElementById('product-category-select').value;
                document.getElementById('matrix-category-name').textContent = category;

                const activeNodes = Array.from(app.nodeMap.values())
                    .filter(n => n.active)
                    .sort((a, b) => a.name.localeCompare(b.name));
                
                const nodeIndexMap = new Map(activeNodes.map((node, i) => [node.id, i]));
                const size = activeNodes.length;

                if (!canvas || size === 0) {
                    if(canvas) {
                        canvas.width = 1;
                        canvas.height = 1;
                        ctx.clearRect(0, 0, 1, 1);
                    }
                    return;
                }
                
                canvas.width = size;
                canvas.height = size;
                
                app.adjacencyMatrix = Array(size).fill(0).map(() => Array(size).fill(0));
                let maxVal = 0;
                let minVal = Infinity;
                
                app.gData.links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    const sourceIndex = nodeIndexMap.get(sourceId);
                    const targetIndex = nodeIndexMap.get(targetId);
                    
                    if (sourceIndex !== undefined && targetIndex !== undefined) {
                        const valueInMillions = link.value / 1000000;
                        app.adjacencyMatrix[sourceIndex][targetIndex] = valueInMillions;
                        if (valueInMillions > maxVal) maxVal = valueInMillions;
                        if (valueInMillions < minVal) minVal = valueInMillions;
                    }
                });

                if (minVal === Infinity) minVal = 0;

                const startColor = [240, 249, 255]; // sky-50
                const endColor = [12, 74, 110];   // sky-900

                const imageData = ctx.createImageData(size, size);
                const logMax = Math.log(maxVal || 1);

                for (let i = 0; i < size; i++) { // Row (y-axis)
                    for (let j = 0; j < size; j++) { // Column (x-axis)
                        const value = app.adjacencyMatrix[i][j];
                        const pixelIndex = (i * size + j) * 4;

                        if (value > 0) {
                            const logRatio = logMax > 0 ? (Math.log(value) / logMax) : 0;
                            imageData.data[pixelIndex] = Math.round(startColor[0] + logRatio * (endColor[0] - startColor[0]));     // R
                            imageData.data[pixelIndex + 1] = Math.round(startColor[1] + logRatio * (endColor[1] - startColor[1])); // G
                            imageData.data[pixelIndex + 2] = Math.round(startColor[2] + logRatio * (endColor[2] - startColor[2])); // B
                            imageData.data[pixelIndex + 3] = 255; // Alpha
                        } else {
                            imageData.data[pixelIndex] = 241;     // R (bg color #f1f5f9)
                            imageData.data[pixelIndex + 1] = 245; // G
                            imageData.data[pixelIndex + 2] = 249; // B
                            imageData.data[pixelIndex + 3] = 255; // Alpha
                        }
                    }
                }
                ctx.putImageData(imageData, 0, 0);
                
                document.getElementById('legend-min').textContent = `${minVal.toFixed(1)}M`;
                document.getElementById('legend-max').textContent = `${maxVal.toFixed(1)}M`;
                document.getElementById('legend-gradient').style.background = `linear-gradient(to right, rgb(${startColor.join(',')}), rgb(${endColor.join(',')}))`;
            },

            normalizeValue(value, minInput, maxInput, minOutput, maxOutput) {
                if (minInput === maxInput) return minOutput;
                return minOutput + (maxOutput - minOutput) * (value - minInput) / (maxInput - minInput);
            },

            getColorForValue(node) {
                if (app.currentView === 'region') return app.regionColors[node.region] || '#6b7280';
                
                const colors = app.centralityColors[app.currentView] || app.centralityColors.closeness;
                const { min, max } = app.viewMinMax[app.currentView] || { min: 0, max: 1 };
                if (min === max) return colors.medium;

                const value = node[app.currentView];
                const normalized = app.normalizeValue(value, min, max, 0, 1);
                
                if (normalized > 0.7) return colors.high;
                if (normalized > 0.4) return colors.medium;
                return colors.low;
            },

            updateGraphData() {
                const activeNodes = Array.from(app.nodeMap.values()).filter(n => n.active);
                const activeNodeIds = new Set(activeNodes.map(n => n.id));
                
                const activeLinks = app.gData.links.filter(l => {
                    const sourceId = typeof l.source === 'object' && l.source !== null ? l.source.id : l.source;
                    const targetId = typeof l.target === 'object' && l.target !== null ? l.target.id : l.target;
                    return activeNodeIds.has(sourceId) && activeNodeIds.has(targetId);
                });

                // --- NEW: Calculate min/max link values ---
                if (activeLinks.length > 0) {
                    let min = Infinity;
                    let max = -Infinity;
                    for (const link of activeLinks) {
                        if (link.value < min) min = link.value;
                        if (link.value > max) max = link.value;
                    }
                    app.linkMinMax = { min, max };
                } else {
                    app.linkMinMax = { min: 0, max: 0 };
                }
                // --- END NEW ---

                const clonedNodes = activeNodes.map(n => ({...n}));
                const clonedLinks = activeLinks.map(l => ({...l}));

                app.graph.graphData({ nodes: clonedNodes, links: clonedLinks });
            },

            setView(viewType) {
                app.currentView = viewType;
                document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`.view-btn[data-view='${viewType}']`)?.classList.add('active');
                app.updateLegend();
                app.graph.nodeCanvasObject(app.graph.nodeCanvasObject()); // Re-render nodes
            },

            updateUI() {
                app.updateViewMinMax();
                app.updateMetrics();
                app.updateCountryButtons();
                app.updateLegend();
                app.updatePartnershipSelectorState();
            },

            updateViewMinMax() {
                Object.keys(app.centralityColors).forEach(view => {
                    app.viewMinMax[view] = { min: Infinity, max: -Infinity };
                });
                app.nodeMap.forEach(c => {
                    if (c.active) {
                        for(const view of Object.keys(app.viewMinMax)) {
                            const val = c[view];
                            if (val < app.viewMinMax[view].min) app.viewMinMax[view].min = val;
                            if (val > app.viewMinMax[view].max) app.viewMinMax[view].max = val;
                        }
                    }
                });
            },
            
            updatePartnershipSelectorState() {
                const select = document.getElementById('partnership-select');
                const activeNodeIds = new Set(
                    Array.from(app.nodeMap.values())
                        .filter(n => n.active)
                        .map(n => n.id)
                );

                let matchedPartnership = null;

                for (const [name, ids] of Object.entries(app.partnerships)) {
                    const partnershipIds = new Set(ids);
                    if (activeNodeIds.size === partnershipIds.size && [...activeNodeIds].every(id => partnershipIds.has(id))) {
                        matchedPartnership = name;
                        break;
                    }
                }

                if (matchedPartnership) {
                    select.value = matchedPartnership;
                } else {
                    select.value = 'custom';
                }
            },

            updateMetrics() {
                const activeNodes = Array.from(app.nodeMap.values()).filter(c => c.active);
                const numNodes = activeNodes.length;
                const activeNodeIds = new Set(activeNodes.map(n => n.id));
                const numLinks = app.gData.links.filter(l => {
                    const sourceId = typeof l.source === 'object' && l.source !== null ? l.source.id : l.source;
                    const targetId = typeof l.target === 'object' && l.target !== null ? l.target.id : l.target;
                    return activeNodeIds.has(sourceId) && activeNodeIds.has(targetId);
                }).length;
                const density = numNodes > 1 ? numLinks / (numNodes * (numNodes - 1)) : 0;
                
                Object.entries({
                    'active-countries': numNodes, 'trade-links': numLinks,
                    'network-density': density.toFixed(3),
                    'active-count': numNodes, 'link-count': numLinks
                }).forEach(([id, value]) => { document.getElementById(id).textContent = value; });
            },

            updateCountryButtons() {
                const container = document.getElementById('country-grid');
                const searchValue = document.getElementById('country-search').value.toLowerCase();
                container.innerHTML = '';
                Array.from(app.nodeMap.values())
                    .filter(c => c.name.toLowerCase().includes(searchValue))
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .forEach(country => {
                        const button = document.createElement('button');
                        button.className = `country-toggle ${country.active ? 'active' : 'inactive'}`;
                        button.textContent = country.name;
                        button.onclick = () => app.toggleCountry(country);
                        container.appendChild(button);
                    });
            },

            toggleCountry(country) {
                const node = app.nodeMap.get(country.id);
                if (node) {
                    node.active = !node.active;
                }
                app.recomputeMetrics();
                app.updateGraphData();
                app.renderAdjacencyMatrix(); // Re-render matrix on country change
            },

            updateLegend() {
                const legendContainer = document.getElementById('legend');
                const titleElement = legendContainer.querySelector('#legend-title');
                
                const existingItems = legendContainer.querySelectorAll('.legend-item, .legend-gradient');
                existingItems.forEach(item => item.remove());
                
                if (app.currentView === 'region') {
                    titleElement.textContent = 'Region';
                    Object.entries(app.regionColors).forEach(([region, color]) => {
                        const legendItem = document.createElement('div');
                        legendItem.className = 'legend-item';
                        legendItem.innerHTML = `<span class="legend-color" style="background-color: ${color};"></span><span>${region}</span>`;
                        legendContainer.appendChild(legendItem);
                    });
                } else {
                    const { min, max } = app.viewMinMax[app.currentView] || { min: 0, max: 1 };
                    const range = max - min;
                    const colors = app.centralityColors[app.currentView] || app.centralityColors.closeness;
                    
                    titleElement.textContent = app.currentView.charAt(0).toUpperCase() + app.currentView.slice(1).replace('_', ' ');
                    
                    const highThreshold = min + (range * 0.7);
                    const mediumThreshold = min + (range * 0.4);
                    
                    const formatLabel = (val) => {
                        if (typeof val !== 'number' || !isFinite(val)) return 'N/A';
                        if (val > 1e6) return `${(val / 1e6).toFixed(1)}M`;
                        if (val > 1e3) return `${(val / 1e3).toFixed(1)}K`;
                        return val.toFixed(2);
                    }

                    const legendData = [
                        { color: colors.high, label: `High: > ${formatLabel(highThreshold)}` },
                        { color: colors.medium, label: `Med: > ${formatLabel(mediumThreshold)}` },
                        { color: colors.low, label: `Low: < ${formatLabel(mediumThreshold)}` }
                    ];
                    
                    legendData.forEach(item => {
                        const legendItem = document.createElement('div');
                        legendItem.className = 'legend-item';
                        legendItem.innerHTML = `<span class="legend-color" style="background-color: ${item.color};"></span><span>${item.label}</span>`;
                        legendContainer.appendChild(legendItem);
                    });
                }
            },
            selectAll() { 
                app.nodeMap.forEach(c => c.active = true); 
                app.recomputeMetrics(); 
                app.updateGraphData(); 
                app.renderAdjacencyMatrix(); 
            },
            selectNone() { 
                app.nodeMap.forEach(c => c.active = false); 
                app.recomputeMetrics(); 
                app.updateGraphData(); 
                app.renderAdjacencyMatrix(); 
            },
            
            selectPartnership(partnershipName) {
                const partnershipCountries = new Set(app.partnerships[partnershipName]);
                app.nodeMap.forEach((node, id) => {
                    node.active = partnershipCountries.has(id);
                });
                app.recomputeMetrics();
                app.updateGraphData();
                app.renderAdjacencyMatrix();
            },

            initializeGraph() {
                console.log("Initializing graph...");
                const container = document.getElementById('graph');
                
                app.graph = ForceGraph()(container)
                    .graphData({ nodes: [], links: [] })
                    .nodeId('id')
                    .nodeVal(node => app.highlightNodes.has(node) ? 12 : 8)
                    .backgroundColor('#f8fafc')
                    .linkColor(link => {
                        const activeNodeCount = app.graph.graphData().nodes.length;
                        const opacity = Math.max(0.1, 1 - activeNodeCount / 200);
                        return `rgba(156, 163, 175, ${app.highlightLinks.has(link) ? 0.8 : opacity})`;
                    })
                    .linkCurvature(0.2)
                    .linkDirectionalArrowLength(link => {
                        const activeNodeCount = app.graph.graphData().nodes.length;
                        return activeNodeCount > 100 && !app.highlightLinks.has(link) ? 0 : 6;
                    })
                    .linkDirectionalArrowRelPos(1)
                    .onNodeDragEnd(node => {
                        node.fx = null;
                        node.fy = null;
                    })
                    .nodeCanvasObject((node, ctx, globalScale) => {
                        const size = app.highlightNodes.has(node) ? 12 : 8;
                        const flagUrl = `./data/country-flags/flag-thumbnail-${node.id}.png`;

                        if (app.flagImageCache[node.id] === undefined) {
                            app.flagImageCache[node.id] = false; 
                            const img = new Image();
                            img.src = flagUrl;
                            img.onload = () => { app.flagImageCache[node.id] = img; };
                            img.onerror = () => { app.flagImageCache[node.id] = null; };
                        }

                        const img = app.flagImageCache[node.id];
                        
                        const borderColor = app.highlightNodes.has(node) 
                            ? (node === app.hoverNode ? 'rgba(239, 68, 68, 0.8)' : 'rgba(251, 146, 0, 0.6)')
                            : app.getColorForValue(node);

                        // Draw border
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, size, 0, 2 * Math.PI, false);
                        ctx.fillStyle = borderColor;
                        ctx.fill();
                        ctx.closePath();

                        if (app.showFlags && img) {
                            ctx.save();
                            const borderSize = 2.5;
                            ctx.beginPath();
                            ctx.arc(node.x, node.y, size - borderSize, 0, 2 * Math.PI, false);
                            ctx.clip();
                            ctx.drawImage(img, node.x - (size - borderSize), node.y - (size - borderSize), (size - borderSize) * 2, (size - borderSize) * 2);
                            ctx.restore();
                        }
                    })
                    .onNodeHover(node => {
                        app.highlightNodes.clear();
                        app.highlightLinks.clear();
                        
                        if (node) {
                            app.highlightNodes.add(node);
                            app.gData.links.forEach(link => {
                                const sourceId = typeof link.source === 'object' && link.source !== null ? link.source.id : link.source;
                                const targetId = typeof link.target === 'object' && link.target !== null ? link.target.id : link.target;

                                if (sourceId === node.id || targetId === node.id) {
                                    app.highlightLinks.add(link);
                                    if(app.nodeMap.has(sourceId)) app.highlightNodes.add(app.nodeMap.get(sourceId));
                                    if(app.nodeMap.has(targetId)) app.highlightNodes.add(app.nodeMap.get(targetId));
                                }
                            });
                        }
                        app.hoverNode = node || null;
                    })
                    .linkWidth(link => {
                        if (app.highlightLinks.has(link)) return 4; // Keep hover highlight strong

                        const activeNodeCount = app.graph.graphData().nodes.length;
                        
                        // If too many nodes (e.g., > 50), just use a thin line
                        if (activeNodeCount > 50) {
                            return 0.5; 
                        }

                        // If few nodes, scale the width
                        const { min, max } = app.linkMinMax;
                        const minDisplayWidth = 0.5;
                        const maxDisplayWidth = 5; // Max width for a link

                        if (min === max) return minDisplayWidth; // Avoid division by zero

                        // Use logarithmic scaling for better visual differentiation
                        const logMin = Math.log(min || 1);
                        const logMax = Math.log(max || 1);
                        const logVal = Math.log(link.value || 1);

                        if (logMin === logMax) return minDisplayWidth;
                        
                        // Use app.normalizeValue on the log-transformed values
                        return app.normalizeValue(logVal, logMin, logMax, minDisplayWidth, maxDisplayWidth);
                    })
                    .linkDirectionalParticles(link => app.highlightLinks.has(link) ? 2 : 0)
                    .linkDirectionalParticleWidth(link => app.highlightLinks.has(link) ? 3 : 0)
                    .nodeLabel(node => {
                        // CRITICAL: Get the *authoritative* node from nodeMap, not the stale graph object
                        const authoritativeNode = app.nodeMap.get(node.id);
                        if (!authoritativeNode) return ""; // Safety check

                        const flagUrl = `./data/country-flags/flag-thumbnail-${authoritativeNode.id}.png`;
                        let tooltipHtml = `<div class="graph-tooltip">
                            <img src="${flagUrl}" class="tooltip-flag" onerror="this.style.display='none'">
                            <div class="tooltip-country">${authoritativeNode.name}</div>`;
                        
                        // Define which keys to show and in what order
                        const keysToShow = ['degree', 'closeness', 'betweenness', 'trade_volume']; // <-- REMOVED 'region'

                        for (const key of keysToShow) {
                            const value = authoritativeNode[key];
                            if (value === undefined) continue;

                            const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            let formattedValue = value;

                            if (typeof value === 'number') {
                                if (key === 'trade_volume') {
                                     if (value > 1e9) formattedValue = `$${(value / 1e9).toFixed(1)}B`;
                                     else if (value > 1e6) formattedValue = `$${(value / 1e6).toFixed(1)}M`;
                                     else if (value > 1e3) formattedValue = `$${(value / 1e3).toFixed(1)}K`;
                                     else formattedValue = `$${value.toFixed(0)}`;
                                }
                                else if (key === 'degree') formattedValue = value.toLocaleString();
                                else if (value < 1 && value > 0) formattedValue = value.toFixed(3);
                                else formattedValue = value.toLocaleString();
                            }
                            
                            tooltipHtml += `<div class="tooltip-row"><span class="tooltip-key">${formattedKey}:</span><span>${formattedValue}</span></div>`;
                        }

                        tooltipHtml += `</div>`;
                        return tooltipHtml;
                    })
                    .linkLabel(link => {
                        const sourceNode = app.nodeMap.get(typeof link.source === 'object' ? link.source.id : link.source);
                        const targetNode = app.nodeMap.get(typeof link.target === 'object' ? link.target.id : link.target);
                        if (!sourceNode || !targetNode) return "";

                        return `<div class="graph-tooltip" style="max-width: 300px;">
                            Exports from <strong>${sourceNode.name}</strong> to <strong>${targetNode.name}</strong><br>
                            Value: $${(link.value / 1000000).toFixed(2)}M
                        </div>`;
                    })
                    .linkHoverPrecision(8);
                
                app.graph.d3Force('charge').strength(-800);
                app.graph.d3Force('link').distance(200);

                app.setView('closeness');
            }
        };

        window.addEventListener('DOMContentLoaded', () => app.init());
        window.app = app;
    </script>
</body>
</html>